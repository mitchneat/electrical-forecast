import { assert } from "./assert";
export function* range(start, stop, step = 1) {
    assert(step > 0);
    const { abs, ceil, max } = Math;
    if (stop == null) {
        stop = start;
        start = 0;
    }
    const delta = start <= stop ? step : -step;
    const length = max(ceil(abs(stop - start) / abs(step)), 0);
    for (let i = 0; i < length; i++, start += delta) {
        yield start;
    }
}
export function* reverse(array) {
    const n = array.length;
    for (let i = 0; i < n; i++) {
        yield array[n - i - 1];
    }
}
export function* enumerate(seq) {
    let i = 0;
    for (const item of seq) {
        yield [item, i++];
    }
}
export function* take(seq, n) {
    assert(n >= 0);
    let i = 0;
    for (const item of seq) {
        if (i++ < n) {
            yield item;
        }
        else {
            break;
        }
    }
}
export function* skip(seq, n) {
    assert(n >= 0);
    for (const value of seq) {
        if (n == 0) {
            yield value;
        }
        else {
            n -= 1;
        }
    }
}
export function* tail(seq) {
    yield* skip(seq, 1);
}
export function* join(seq, separator) {
    let first = true;
    for (const entry of seq) {
        if (first) {
            first = false;
        }
        else if (separator != null) {
            yield separator();
        }
        yield* entry;
    }
}
export function* zip(iterable0, iterable1) {
    const it0 = iterable0[Symbol.iterator]();
    const it1 = iterable1[Symbol.iterator]();
    do {
        const r0 = it0.next();
        const r1 = it1.next();
        if (r0.done === true || r1.done === true) {
            break;
        }
        else {
            yield [r0.value, r1.value];
        }
    } while (true);
}
export function* interleave(seq, separator) {
    let first = true;
    for (const entry of seq) {
        if (first) {
            first = false;
        }
        else {
            yield separator();
        }
        yield entry;
    }
}
export function* map(iterable, fn) {
    let i = 0;
    for (const item of iterable) {
        yield fn(item, i++);
    }
}
export function* flat_map(iterable, fn) {
    let i = 0;
    for (const item of iterable) {
        yield* fn(item, i++);
    }
}
export function* filter(iterable, fn) {
    let i = 0;
    for (const item of iterable) {
        if (fn(item, i++)) {
            yield item;
        }
    }
}
const nothing = Symbol("nothing");
export function* no_repeated(iterable) {
    let last = nothing;
    for (const item of iterable) {
        if (item !== last) {
            yield item;
        }
        last = item;
    }
}
export function every(iterable, predicate) {
    for (const item of iterable) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
export function some(iterable, predicate) {
    for (const item of iterable) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
// https://docs.python.org/3.8/library/itertools.html#itertools.combinations
export function* combinations(seq, r) {
    const n = seq.length;
    if (r > n) {
        return;
    }
    const indices = [...range(r)];
    yield indices.map((i) => seq[i]);
    while (true) {
        let k;
        for (const i of range(r - 1, -1)) {
            if (indices[i] != i + n - r) {
                k = i;
                break;
            }
        }
        if (k == null) {
            return;
        }
        indices[k] += 1;
        for (const j of range(k + 1, r)) {
            indices[j] = indices[j - 1] + 1;
        }
        yield indices.map((i) => seq[i]);
    }
}
export function* subsets(seq) {
    for (const k of range(seq.length + 1)) {
        yield* combinations(seq, k);
    }
}
export function min(iterable) {
    let result = Infinity;
    for (const value of iterable) {
        if (!isNaN(value) && value < result) {
            result = value;
        }
    }
    return result;
}
export function max(iterable) {
    let result = -Infinity;
    for (const value of iterable) {
        if (!isNaN(value) && value > result) {
            result = value;
        }
    }
    return result;
}
export function minmax(iterable) {
    let min = +Infinity;
    let max = -Infinity;
    for (const value of iterable) {
        if (!isNaN(value)) {
            if (value < min) {
                min = value;
            }
            if (value > max) {
                max = value;
            }
        }
    }
    return [min, max];
}
//# sourceMappingURL=iterator.js.map