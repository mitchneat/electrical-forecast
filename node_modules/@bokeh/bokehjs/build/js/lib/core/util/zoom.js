import { assert } from "./assert";
import { minmax } from "./math";
export function scale_interval(range, factor, center) {
    assert(Math.abs(factor) < 1);
    const [min, max] = minmax(range.start, range.end);
    const x = center ?? (max + min) / 2.0;
    const x0 = min - (min - x) * factor;
    const x1 = max - (max - x) * factor;
    return [x0, x1];
}
export function get_info(scales, [sxy0, sxy1]) {
    const info = new Map();
    for (const scale of scales) {
        const [start, end] = scale.r_invert(sxy0, sxy1);
        info.set(scale.source_range, { start, end });
    }
    return info;
}
export function rescale(scales, factor, center) {
    const output = new Map();
    for (const scale of scales) {
        const [v0, v1] = scale_interval(scale.target_range, factor, center);
        const [start, end] = scale.r_invert(v0, v1);
        output.set(scale.source_range, { start, end });
    }
    return output;
}
export function scale_range(x_scales, y_scales, _x_target, _y_range, factor, x_axis = true, y_axis = true, center) {
    /*
     * Utility function for zoom tools to calculate/create the zoom_info object
     * of the form required by `PlotView.update_range`.
     */
    // Here we are a bit careful to only update the range info for dimensions that
    // are "in play". This is to avoid superfluous noise updates to dataranges that
    // would cause windowed auto-ranging to turn off.
    const xrs = x_axis ? rescale(x_scales, factor, center?.x) : new Map();
    const yrs = y_axis ? rescale(y_scales, factor, center?.y) : new Map();
    // OK this sucks we can't set factor independently in each direction. It is used
    // for GMap plots, and GMap plots always preserve aspect, so effective the value
    // of 'dimensions' is ignored.
    return { xrs, yrs, factor };
}
//# sourceMappingURL=zoom.js.map